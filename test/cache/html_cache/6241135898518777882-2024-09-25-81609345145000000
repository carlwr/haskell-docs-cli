[{"docs":"<i>Note:</i> You should use <a>Data.Map.Strict</a> instead of this\nmodule if:\n\n<ul>\n<li>You will eventually need all the values stored.</li>\n<li>The stored values don't represent large virtual data structures to\nbe lazily computed.</li>\n</ul>\n\nAn efficient implementation of ordered maps from keys to values\n(dictionaries).\n\nThese modules are intended to be imported qualified, to avoid name\nclashes with Prelude functions, e.g.\n\n<pre>\nimport qualified Data.Map as Map\n</pre>\n\nThe implementation of <a>Map</a> is based on <i>size balanced</i>\nbinary trees (or trees of <i>bounded balance</i>) as described by:\n\n<ul>\n<li>Stephen Adams, \"<i>Efficient sets: a balancing act</i>\", Journal\nof Functional Programming 3(4):553-562, October 1993,\n<a>http://www.swiss.ai.mit.edu/~adams/BB/</a>.</li>\n<li>J. Nievergelt and E.M. Reingold, \"<i>Binary search trees of\nbounded balance</i>\", SIAM journal of computing 2(1), March 1973.</li>\n</ul>\n\nBounds for <a>union</a>, <a>intersection</a>, and <a>difference</a>\nare as given by\n\n<ul>\n<li>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, \"<i>Just Join for\nParallel Ordered Sets</i>\",\n<a>https://arxiv.org/abs/1602.02120v3</a>.</li>\n</ul>\n\nNote that the implementation is <i>left-biased</i> -- the elements of\na first argument are always preferred to the second, for example in\n<a>union</a> or <a>insert</a>.\n\n<i>Warning</i>: The size of the map must not exceed\n<tt>maxBound::Int</tt>. Violation of this condition is not detected\nand if the size limit is exceeded, its behaviour is undefined.\n\nOperation comments contain the operation time complexity in the Big-O\nnotation (<a>http://en.wikipedia.org/wiki/Big_O_notation</a>).\n","item":"<b>module</b> Data.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"type":"module","url":"https://hackage.haskell.org/package/containers/docs/Data-Map.html"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"Data.Map.Internal","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Internal.html"},"package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"type":"","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Internal.html#t:Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"Data.Map.Lazy","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html"},"package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"type":"","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#t:Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"Data.Map.Strict","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html"},"package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"type":"","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"Data.Map.Strict.Internal","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Strict-Internal.html"},"package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"type":"","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Strict-Internal.html#t:Map"},{"docs":"","item":"<b>module</b> GHC.Types.Unique.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"ghc","url":"https://hackage.haskell.org/package/ghc"},"type":"module","url":"https://hackage.haskell.org/package/ghc/docs/GHC-Types-Unique-Map.html"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"Protolude","url":"https://hackage.haskell.org/package/protolude/docs/Protolude.html"},"package":{"name":"protolude","url":"https://hackage.haskell.org/package/protolude"},"type":"","url":"https://hackage.haskell.org/package/protolude/docs/Protolude.html#t:Map"},{"docs":"Invariant preserving version of <tt>Map</tt> from the\n<tt>containers</tt> packages, suitable for use with <tt>Uniplate</tt>.\nUse <a>toMap</a> to construct values, and <a>fromMap</a> to\ndeconstruct values.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k v","module":{"name":"Data.Generics.Uniplate.Data.Instances","url":"https://hackage.haskell.org/package/uniplate/docs/Data-Generics-Uniplate-Data-Instances.html"},"package":{"name":"uniplate","url":"https://hackage.haskell.org/package/uniplate"},"type":"","url":"https://hackage.haskell.org/package/uniplate/docs/Data-Generics-Uniplate-Data-Instances.html#t:Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> () =&gt; <span class=name><s0>Map</s0></span> k a","module":{"name":"Relude.Container.Reexport","url":"https://hackage.haskell.org/package/relude/docs/Relude-Container-Reexport.html"},"package":{"name":"relude","url":"https://hackage.haskell.org/package/relude"},"type":"","url":"https://hackage.haskell.org/package/relude/docs/Relude-Container-Reexport.html#t:Map"},{"docs":"Contains implementation of polymorphic type classes for data types\n<a>Set</a> and <a>Map</a>.\n","item":"<b>module</b> Relude.Extra.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"relude","url":"https://hackage.haskell.org/package/relude"},"type":"module","url":"https://hackage.haskell.org/package/relude/docs/Relude-Extra-Map.html"},{"docs":"Strict <tt>Map</tt>. Import as:\n\n<pre>\nimport qualified RIO.Map as Map\n</pre>\n\nThis module does not export any partial or unchecked functions. For\nthose, see <a>RIO.Map.Partial</a> and <a>RIO.Map.Unchecked</a>\n","item":"<b>module</b> RIO.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"rio","url":"https://hackage.haskell.org/package/rio"},"type":"module","url":"https://hackage.haskell.org/package/rio/docs/RIO-Map.html"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"RIO.Map","url":"https://hackage.haskell.org/package/rio/docs/RIO-Map.html"},"package":{"name":"rio","url":"https://hackage.haskell.org/package/rio"},"type":"","url":"https://hackage.haskell.org/package/rio/docs/RIO-Map.html#t:Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"RIO.Prelude.Types","url":"https://hackage.haskell.org/package/rio/docs/RIO-Prelude-Types.html"},"package":{"name":"rio","url":"https://hackage.haskell.org/package/rio"},"type":"","url":"https://hackage.haskell.org/package/rio/docs/RIO-Prelude-Types.html#t:Map"},{"docs":"Instances to convert between Map and association list.\n\nCopyright (C) 2009-2011 John Goerzen <a>jgoerzen@complete.org</a>\n\nAll rights reserved.\n\nFor license and copyright information, see the file LICENSE\n","item":"<b>module</b> Data.Convertible.Instances.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"convertible","url":"https://hackage.haskell.org/package/convertible"},"type":"module","url":"https://hackage.haskell.org/package/convertible/docs/Data-Convertible-Instances-Map.html"},{"docs":"<a>Map</a> type used to represent records and unions\n","item":"<b>module</b> Dhall.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"dhall","url":"https://hackage.haskell.org/package/dhall"},"type":"module","url":"https://hackage.haskell.org/package/dhall/docs/Dhall-Map.html"},{"docs":"A <a>Map</a> that remembers the original ordering of keys\n\nThis is primarily used so that formatting preserves field order\n\nThis is done primarily to avoid a dependency on\n<tt>insert-ordered-containers</tt> and also to improve performance\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k v","module":{"name":"Dhall.Map","url":"https://hackage.haskell.org/package/dhall/docs/Dhall-Map.html"},"package":{"name":"dhall","url":"https://hackage.haskell.org/package/dhall"},"type":"","url":"https://hackage.haskell.org/package/dhall/docs/Dhall-Map.html#t:Map"},{"docs":"","item":"<b>module</b> Data.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"rerebase","url":"https://hackage.haskell.org/package/rerebase"},"type":"module","url":"https://hackage.haskell.org/package/rerebase/docs/Data-Map.html"},{"docs":"","item":"<b>module</b> Data.NonEmpty.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"non-empty","url":"https://hackage.haskell.org/package/non-empty"},"type":"module","url":"https://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Map.html"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"ClassyPrelude","url":"https://hackage.haskell.org/package/classy-prelude/docs/ClassyPrelude.html"},"package":{"name":"classy-prelude","url":"https://hackage.haskell.org/package/classy-prelude"},"type":"","url":"https://hackage.haskell.org/package/classy-prelude/docs/ClassyPrelude.html#t:Map"},{"docs":"","item":"<b>module</b> Data.Dependent.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"dependent-map","url":"https://hackage.haskell.org/package/dependent-map"},"type":"module","url":"https://hackage.haskell.org/package/dependent-map/docs/Data-Dependent-Map.html"},{"docs":"","item":"<b>module</b> StmContainers.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"stm-containers","url":"https://hackage.haskell.org/package/stm-containers"},"type":"module","url":"https://hackage.haskell.org/package/stm-containers/docs/StmContainers-Map.html"},{"docs":"Hash-table, based on STM-specialized Hash Array Mapped Trie.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> key value","module":{"name":"StmContainers.Map","url":"https://hackage.haskell.org/package/stm-containers/docs/StmContainers-Map.html"},"package":{"name":"stm-containers","url":"https://hackage.haskell.org/package/stm-containers"},"type":"","url":"https://hackage.haskell.org/package/stm-containers/docs/StmContainers-Map.html#t:Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> () =&gt; <span class=name><s0>Map</s0></span> k a","module":{"name":"Distribution.Compat.Prelude","url":"https://hackage.haskell.org/package/Cabal-syntax/docs/Distribution-Compat-Prelude.html"},"package":{"name":"Cabal-syntax","url":"https://hackage.haskell.org/package/Cabal-syntax"},"type":"","url":"https://hackage.haskell.org/package/Cabal-syntax/docs/Distribution-Compat-Prelude.html#t:Map"},{"docs":"Type-level <a>fmap</a> for type-level functors.\n\nNote: this name clashes with <a>Map</a> from <i>containers</i>.\n<a>FMap</a> is provided as a synonym to avoid this.\n\n<h3><b>Example</b></h3>\n\n<pre>\n&gt;&gt;&gt; data Example where Ex :: a -&gt; Example  -- Hide the type of examples to avoid brittleness in different GHC versions\n\n&gt;&gt;&gt; data AddMul :: Nat -&gt; Nat -&gt; Exp Nat\n\n&gt;&gt;&gt; type instance Eval (AddMul x y) = (x TL.+ y) TL.* (x TL.+ y)\n\n&gt;&gt;&gt; :kind! Ex (Eval (Map (AddMul 2) '[0, 1, 2, 3, 4]) :: [Nat])\nEx (Eval (Map (AddMul 2) '[0, 1, 2, 3, 4]) :: [Nat]) :: Example\n= Ex [4, 9, 16, 25, 36]\n</pre>\n","item":"<b>data</b> <span class=name><s0>Map</s0></span>","module":{"name":"Fcf","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf.html"},"package":{"name":"first-class-families","url":"https://hackage.haskell.org/package/first-class-families"},"type":"","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf.html#t:Map"},{"docs":"Type-level <a>fmap</a> for type-level functors.\n\nNote: this name clashes with <a>Map</a> from <i>containers</i>.\n<a>FMap</a> is provided as a synonym to avoid this.\n\n<h3><b>Example</b></h3>\n\n<pre>\n&gt;&gt;&gt; data Example where Ex :: a -&gt; Example  -- Hide the type of examples to avoid brittleness in different GHC versions\n\n&gt;&gt;&gt; data AddMul :: Nat -&gt; Nat -&gt; Exp Nat\n\n&gt;&gt;&gt; type instance Eval (AddMul x y) = (x TL.+ y) TL.* (x TL.+ y)\n\n&gt;&gt;&gt; :kind! Ex (Eval (Map (AddMul 2) '[0, 1, 2, 3, 4]) :: [Nat])\nEx (Eval (Map (AddMul 2) '[0, 1, 2, 3, 4]) :: [Nat]) :: Example\n= Ex [4, 9, 16, 25, 36]\n</pre>\n","item":"<b>data</b> <span class=name><s0>Map</s0></span>","module":{"name":"Fcf.Class.Functor","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Class-Functor.html"},"package":{"name":"first-class-families","url":"https://hackage.haskell.org/package/first-class-families"},"type":"","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Class-Functor.html#t:Map"},{"docs":"Type-level <a>fmap</a> for type-level functors.\n\nNote: this name clashes with <a>Map</a> from <i>containers</i>.\n<a>FMap</a> is provided as a synonym to avoid this.\n\n<h3><b>Example</b></h3>\n\n<pre>\n&gt;&gt;&gt; data Example where Ex :: a -&gt; Example  -- Hide the type of examples to avoid brittleness in different GHC versions\n\n&gt;&gt;&gt; data AddMul :: Nat -&gt; Nat -&gt; Exp Nat\n\n&gt;&gt;&gt; type instance Eval (AddMul x y) = (x TL.+ y) TL.* (x TL.+ y)\n\n&gt;&gt;&gt; :kind! Ex (Eval (Map (AddMul 2) '[0, 1, 2, 3, 4]) :: [Nat])\nEx (Eval (Map (AddMul 2) '[0, 1, 2, 3, 4]) :: [Nat]) :: Example\n= Ex [4, 9, 16, 25, 36]\n</pre>\n","item":"<b>data</b> <span class=name><s0>Map</s0></span>","module":{"name":"Fcf.Classes","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Classes.html"},"package":{"name":"first-class-families","url":"https://hackage.haskell.org/package/first-class-families"},"type":"","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Classes.html#t:Map"},{"docs":"","item":"<b>type family</b> <span class=name><s0>Map</s0></span> (a1 :: a ~&gt; b) (a2 :: NonEmpty a) :: NonEmpty b","module":{"name":"Data.List.NonEmpty.Singletons","url":"https://hackage.haskell.org/package/singletons-base/docs/Data-List-NonEmpty-Singletons.html"},"package":{"name":"singletons-base","url":"https://hackage.haskell.org/package/singletons-base"},"type":"","url":"https://hackage.haskell.org/package/singletons-base/docs/Data-List-NonEmpty-Singletons.html#t:Map"},{"docs":"","item":"<b>type family</b> <span class=name><s0>Map</s0></span> (a1 :: a ~&gt; b) (a2 :: [a]) :: [b]","module":{"name":"Data.List.Singletons","url":"https://hackage.haskell.org/package/singletons-base/docs/Data-List-Singletons.html"},"package":{"name":"singletons-base","url":"https://hackage.haskell.org/package/singletons-base"},"type":"","url":"https://hackage.haskell.org/package/singletons-base/docs/Data-List-Singletons.html#t:Map"},{"docs":"","item":"<b>type family</b> <span class=name><s0>Map</s0></span> (a1 :: a ~&gt; b) (a2 :: [a]) :: [b]","module":{"name":"Prelude.Singletons","url":"https://hackage.haskell.org/package/singletons-base/docs/Prelude-Singletons.html"},"package":{"name":"singletons-base","url":"https://hackage.haskell.org/package/singletons-base"},"type":"","url":"https://hackage.haskell.org/package/singletons-base/docs/Prelude-Singletons.html#t:Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"CorePrelude","url":"https://hackage.haskell.org/package/basic-prelude/docs/CorePrelude.html"},"package":{"name":"basic-prelude","url":"https://hackage.haskell.org/package/basic-prelude"},"type":"","url":"https://hackage.haskell.org/package/basic-prelude/docs/CorePrelude.html#t:Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> () =&gt; <span class=name><s0>Map</s0></span> k a","module":{"name":"Universum.Container.Reexport","url":"https://hackage.haskell.org/package/universum/docs/Universum-Container-Reexport.html"},"package":{"name":"universum","url":"https://hackage.haskell.org/package/universum"},"type":"","url":"https://hackage.haskell.org/package/universum/docs/Universum-Container-Reexport.html#t:Map"},{"docs":"TOML-specific combinators for converting between TOML and Haskell\nMap-like data types.\n\nThere are two way to represent map-like structures with the\n<tt>tomland</tt> library.\n\n<ul>\n<li>Map structure with the key and value represented as key-value\npairs:<pre>foo = [ {myKey = \"name\", myVal = 42} , {myKey =\n\"otherName\", myVal = 100} ] </pre></li>\n<li>Map structure as a table with the <tt>TOML</tt> key as the map\nkey:<pre>[foo] name = 42 otherName = 100 </pre></li>\n</ul>\n\nYou can find both types of the codecs in this module for different\nmap-like structures. See the following table for the heads up:\n\nTODO: table\n\n<b>Note:</b> in case of the missing key on the <tt>TOML</tt> side an\nempty map structure is returned.\n","item":"<b>module</b> Toml.Codec.Combinator.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"tomland","url":"https://hackage.haskell.org/package/tomland"},"type":"module","url":"https://hackage.haskell.org/package/tomland/docs/Toml-Codec-Combinator-Map.html"},{"docs":"Map a type level function over a Row.\n","item":"<b>type family</b> <span class=name><s0>Map</s0></span> (f :: a -&gt; b) (r :: Row a) :: Row b","module":{"name":"Data.Row.Internal","url":"https://hackage.haskell.org/package/row-types/docs/Data-Row-Internal.html"},"package":{"name":"row-types","url":"https://hackage.haskell.org/package/row-types"},"type":"","url":"https://hackage.haskell.org/package/row-types/docs/Data-Row-Internal.html#t:Map"},{"docs":"Map a type level function over a Row.\n","item":"<b>type family</b> <span class=name><s0>Map</s0></span> (f :: a -&gt; b) (r :: Row a) :: Row b","module":{"name":"Data.Row.Records","url":"https://hackage.haskell.org/package/row-types/docs/Data-Row-Records.html"},"package":{"name":"row-types","url":"https://hackage.haskell.org/package/row-types"},"type":"","url":"https://hackage.haskell.org/package/row-types/docs/Data-Row-Records.html#t:Map"},{"docs":"Map a type level function over a Row.\n","item":"<b>type family</b> <span class=name><s0>Map</s0></span> (f :: a -&gt; b) (r :: Row a) :: Row b","module":{"name":"Data.Row.Variants","url":"https://hackage.haskell.org/package/row-types/docs/Data-Row-Variants.html"},"package":{"name":"row-types","url":"https://hackage.haskell.org/package/row-types"},"type":"","url":"https://hackage.haskell.org/package/row-types/docs/Data-Row-Variants.html#t:Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"IHaskellPrelude","url":"https://hackage.haskell.org/package/ihaskell/docs/IHaskellPrelude.html"},"package":{"name":"ihaskell","url":"https://hackage.haskell.org/package/ihaskell"},"type":"","url":"https://hackage.haskell.org/package/ihaskell/docs/IHaskellPrelude.html#t:Map"},{"docs":"Lists of pairs representing maps. The <a>Listable</a> <a>tiers</a>\nenumeration will not have repeated maps.\n\n<pre>\n&gt; take 6 (list :: [Map Nat Nat])\n[Map [],Map [(0,0)],Map [(0,1)],Map [(1,0)],Map [(0,2)],Map [(1,1)]]\n</pre>\n","item":"<b>newtype</b> <span class=name><s0>Map</s0></span> a b","module":{"name":"Test.LeanCheck.Utils.Types","url":"https://hackage.haskell.org/package/leancheck/docs/Test-LeanCheck-Utils-Types.html"},"package":{"name":"leancheck","url":"https://hackage.haskell.org/package/leancheck"},"type":"","url":"https://hackage.haskell.org/package/leancheck/docs/Test-LeanCheck-Utils-Types.html#t:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: [(a, b)] -&gt; Map a b","module":{"name":"Test.LeanCheck.Utils.Types","url":"https://hackage.haskell.org/package/leancheck/docs/Test-LeanCheck-Utils-Types.html"},"package":{"name":"leancheck","url":"https://hackage.haskell.org/package/leancheck"},"type":"","url":"https://hackage.haskell.org/package/leancheck/docs/Test-LeanCheck-Utils-Types.html#v:Map"},{"docs":"This module defines finite maps where the key and value types are\nparameterized by an arbitrary kind.\n\nSome code was adapted from containers.\n","item":"<b>module</b> Data.Parameterized.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"parameterized-utils","url":"https://hackage.haskell.org/package/parameterized-utils"},"type":"module","url":"https://hackage.haskell.org/package/parameterized-utils/docs/Data-Parameterized-Map.html"},{"docs":"","item":"<b>module</b> GHC.Types.Unique.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"ghc-lib-parser","url":"https://hackage.haskell.org/package/ghc-lib-parser"},"type":"module","url":"https://hackage.haskell.org/package/ghc-lib-parser/docs/GHC-Types-Unique-Map.html"},{"docs":"","item":"<b>module</b> Language.Haskell.TH.Lib.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"ghc-lib-parser","url":"https://hackage.haskell.org/package/ghc-lib-parser"},"type":"module","url":"https://hackage.haskell.org/package/ghc-lib-parser/docs/Language-Haskell-TH-Lib-Map.html"},{"docs":"","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"Language.Haskell.TH.Lib.Map","url":"https://hackage.haskell.org/package/ghc-lib-parser/docs/Language-Haskell-TH-Lib-Map.html"},"package":{"name":"ghc-lib-parser","url":"https://hackage.haskell.org/package/ghc-lib-parser"},"type":"","url":"https://hackage.haskell.org/package/ghc-lib-parser/docs/Language-Haskell-TH-Lib-Map.html#t:Map"},{"docs":"","item":"<b>module</b> Agda.Utils.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"Agda","url":"https://hackage.haskell.org/package/Agda"},"type":"module","url":"https://hackage.haskell.org/package/Agda/docs/Agda-Utils-Map.html"},{"docs":"","item":"<b>type family</b> <span class=name><s0>Map</s0></span> (f :: Function k l -&gt; Type) (as :: [k]) :: [l]","module":{"name":"Agda.Utils.TypeLevel","url":"https://hackage.haskell.org/package/Agda/docs/Agda-Utils-TypeLevel.html"},"package":{"name":"Agda","url":"https://hackage.haskell.org/package/Agda"},"type":"","url":"https://hackage.haskell.org/package/Agda/docs/Agda-Utils-TypeLevel.html#t:Map"},{"docs":"The abstract type of a <tt>Map</tt>. Its interface is a suitable\nsubset of <a>IntMap</a>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k v","module":{"name":"Data.HashMap","url":"https://hackage.haskell.org/package/hashmap/docs/Data-HashMap.html"},"package":{"name":"hashmap","url":"https://hackage.haskell.org/package/hashmap"},"type":"","url":"https://hackage.haskell.org/package/hashmap/docs/Data-HashMap.html#t:Map"},{"docs":"","item":"<b>data</b> <span class=name><s0>Map</s0></span> measA vertA horizA measB vertB horizB height width","module":{"name":"Numeric.LAPACK.Matrix.Extent","url":"https://hackage.haskell.org/package/lapack/docs/Numeric-LAPACK-Matrix-Extent.html"},"package":{"name":"lapack","url":"https://hackage.haskell.org/package/lapack"},"type":"","url":"https://hackage.haskell.org/package/lapack/docs/Numeric-LAPACK-Matrix-Extent.html#t:Map"},{"docs":"","item":"<b>module</b> Data.Validity.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"validity-containers","url":"https://hackage.haskell.org/package/validity-containers"},"type":"module","url":"https://hackage.haskell.org/package/validity-containers/docs/Data-Validity-Map.html"},{"docs":"","item":"<b>module</b> Data.GenValidity.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"genvalidity-containers","url":"https://hackage.haskell.org/package/genvalidity-containers"},"type":"module","url":"https://hackage.haskell.org/package/genvalidity-containers/docs/Data-GenValidity-Map.html"},{"docs":"List map\n\n<pre>\n&gt;&gt;&gt; :kind! Map NotSym [True, False]\nMap NotSym [True, False] :: [Bool]\n= [False, True]\n</pre>\n\n<pre>\n&gt;&gt;&gt; :kind! Map (Con1 Just) [1, 2, 3]\nMap (Con1 Just) [1, 2, 3] :: [Maybe Natural]\n= [Just 1, Just 2, Just 3]\n</pre>\n","item":"<b>type family</b> <span class=name><s0>Map</s0></span> f xs","module":{"name":"DeFun.List","url":"https://hackage.haskell.org/package/defun-core/docs/DeFun-List.html"},"package":{"name":"defun-core","url":"https://hackage.haskell.org/package/defun-core"},"type":"","url":"https://hackage.haskell.org/package/defun-core/docs/DeFun-List.html#t:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: Schema -&gt; Schema","module":{"name":"Data.Avro","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro.html"},"package":{"name":"avro","url":"https://hackage.haskell.org/package/avro"},"type":"","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro.html#v:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: HashMap Text Value -&gt; Value","module":{"name":"Data.Avro.Encoding.FromAvro","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Encoding-FromAvro.html"},"package":{"name":"avro","url":"https://hackage.haskell.org/package/avro"},"type":"","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Encoding-FromAvro.html#v:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: ReadSchema -&gt; ReadSchema","module":{"name":"Data.Avro.Schema.ReadSchema","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Schema-ReadSchema.html"},"package":{"name":"avro","url":"https://hackage.haskell.org/package/avro"},"type":"","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Schema-ReadSchema.html#v:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: Schema -&gt; Schema","module":{"name":"Data.Avro.Schema.Schema","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Schema-Schema.html"},"package":{"name":"avro","url":"https://hackage.haskell.org/package/avro"},"type":"","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Schema-Schema.html#v:Map"},{"docs":"","item":"<b>module</b> Opaleye.Internal.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"opaleye","url":"https://hackage.haskell.org/package/opaleye"},"type":"module","url":"https://hackage.haskell.org/package/opaleye/docs/Opaleye-Internal-Map.html"},{"docs":"","item":"<b>type family</b> <span class=name><s0>Map</s0></span> f x","module":{"name":"Opaleye.Internal.Map","url":"https://hackage.haskell.org/package/opaleye/docs/Opaleye-Internal-Map.html"},"package":{"name":"opaleye","url":"https://hackage.haskell.org/package/opaleye"},"type":"","url":"https://hackage.haskell.org/package/opaleye/docs/Opaleye-Internal-Map.html#t:Map"},{"docs":"","item":"<b>module</b> Rebase.Data.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"type":"module","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Data-Map.html"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> () =&gt; <span class=name><s0>Map</s0></span> k a","module":{"name":"Rebase.Prelude","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html"},"package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"type":"","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html#t:Map"},{"docs":"Bijections via strict maps.\n","item":"<b>module</b> Data.Bijection.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"bimaps","url":"https://hackage.haskell.org/package/bimaps"},"type":"module","url":"https://hackage.haskell.org/package/bimaps/docs/Data-Bijection-Map.html"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"Data.Bijection.Map","url":"https://hackage.haskell.org/package/bimaps/docs/Data-Bijection-Map.html"},"package":{"name":"bimaps","url":"https://hackage.haskell.org/package/bimaps"},"type":"","url":"https://hackage.haskell.org/package/bimaps/docs/Data-Bijection-Map.html#t:Map"},{"docs":"A mapping from keys to values.\n\nThe keys in a map needs to be an instance of the <a>Key</a> typeclass.\nInstances are already provided for many common element types.\n\n<a>Map</a> implements <a>Foldable</a>, <a>Monoid</a>, etc so many\ncommon operations such as <a>foldr</a> to reduce the structure with a\nright fold, <a>length</a> to get the number of key/value pairs in the\ndictionary, <a>null</a> to test whether the map is empty, and\n(<a>&lt;&gt;</a>) to join two maps together are available.\n\nTo convert to other dictionary types see <a>fromMap</a> below.\n\n(this is a thin wrapper around <b>unordered-containers</b>'s\n<a>HashMap</a>, but if you use the conversion functions to extract the\nkey/value pairs in a list the list will be ordered according to the\nkeys' <a>Ord</a> instance)\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> κ ν","module":{"name":"Core.Data.Structures","url":"https://hackage.haskell.org/package/core-data/docs/Core-Data-Structures.html"},"package":{"name":"core-data","url":"https://hackage.haskell.org/package/core-data"},"type":"","url":"https://hackage.haskell.org/package/core-data/docs/Core-Data-Structures.html#t:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: (a -&gt; b) -&gt; (b -&gt; a) -&gt; (b :-&gt; c) -&gt; a :-&gt; c","module":{"name":"Hedgehog.Function.Internal","url":"https://hackage.haskell.org/package/hedgehog-fn/docs/Hedgehog-Function-Internal.html"},"package":{"name":"hedgehog-fn","url":"https://hackage.haskell.org/package/hedgehog-fn"},"type":"","url":"https://hackage.haskell.org/package/hedgehog-fn/docs/Hedgehog-Function-Internal.html#v:Map"},{"docs":"","item":"<b>module</b> Network.Wai.Session.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"wai-session","url":"https://hackage.haskell.org/package/wai-session"},"type":"module","url":"https://hackage.haskell.org/package/wai-session/docs/Network-Wai-Session-Map.html"},{"docs":"","item":"<b>module</b> Numeric.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"algebra","url":"https://hackage.haskell.org/package/algebra"},"type":"module","url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html"},{"docs":"linear maps from elements of a free module to another free module over\nr\n\n<pre>\nf $# x + y = (f $# x) + (f $# y)\nf $# (r .* x) = r .* (f $# x)\n</pre>\n\n<tt>Map r b a</tt> represents a linear mapping from a free module with\nbasis <tt>a</tt> over <tt>r</tt> to a free module with basis\n<tt>b</tt> over <tt>r</tt>.\n\nNote well the reversed direction of the arrow, due to the\ncontravariance of change of basis!\n\nThis way enables we can employ arbitrary pure functions as linear maps\nby lifting them using <a>arr</a>, or build them by using the monad\ninstance for Map r b. As a consequence Map is an instance of, well,\nalmost everything.\n","item":"<b>newtype</b> <span class=name><s0>Map</s0></span> r b a","module":{"name":"Numeric.Map","url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html"},"package":{"name":"algebra","url":"https://hackage.haskell.org/package/algebra"},"type":"","url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html#t:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: ((a -&gt; r) -&gt; b -&gt; r) -&gt; Map r b a","module":{"name":"Numeric.Map","url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html"},"package":{"name":"algebra","url":"https://hackage.haskell.org/package/algebra"},"type":"","url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html#v:Map"},{"docs":"A map based on <a>Strict</a>. O(log(n)) for most operations.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> c","module":{"name":"Apecs","url":"https://hackage.haskell.org/package/apecs/docs/Apecs.html"},"package":{"name":"apecs","url":"https://hackage.haskell.org/package/apecs"},"type":"","url":"https://hackage.haskell.org/package/apecs/docs/Apecs.html#t:Map"},{"docs":"A map based on <a>Strict</a>. O(log(n)) for most operations.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> c","module":{"name":"Apecs.Stores","url":"https://hackage.haskell.org/package/apecs/docs/Apecs-Stores.html"},"package":{"name":"apecs","url":"https://hackage.haskell.org/package/apecs"},"type":"","url":"https://hackage.haskell.org/package/apecs/docs/Apecs-Stores.html#t:Map"},{"docs":"","item":"<b>module</b> Data.Monoid.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"stack","url":"https://hackage.haskell.org/package/stack"},"type":"module","url":"https://hackage.haskell.org/package/stack/docs/Data-Monoid-Map.html"},{"docs":"","item":"<b>data</b> () =&gt; <span class=name><s0>Map</s0></span> k a","module":{"name":"Stack.Prelude","url":"https://hackage.haskell.org/package/stack/docs/Stack-Prelude.html"},"package":{"name":"stack","url":"https://hackage.haskell.org/package/stack"},"type":"","url":"https://hackage.haskell.org/package/stack/docs/Stack-Prelude.html#t:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: ExecutionHint","module":{"name":"Database.Bloodhound.Common.Types","url":"https://hackage.haskell.org/package/bloodhound/docs/Database-Bloodhound-Common-Types.html"},"package":{"name":"bloodhound","url":"https://hackage.haskell.org/package/bloodhound"},"type":"","url":"https://hackage.haskell.org/package/bloodhound/docs/Database-Bloodhound-Common-Types.html#v:Map"},{"docs":"Utilities for mapping or transforming <a>Expr</a>s.\n","item":"<b>module</b> Data.Express.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"express","url":"https://hackage.haskell.org/package/express"},"type":"module","url":"https://hackage.haskell.org/package/express/docs/Data-Express-Map.html"},{"docs":"<pre>\n{:a map}\n</pre>\n","item":"<span class=name><s0>Map</s0></span> :: EDNMap -&gt; Value","module":{"name":"Data.EDN","url":"https://hackage.haskell.org/package/hedn/docs/Data-EDN.html"},"package":{"name":"hedn","url":"https://hackage.haskell.org/package/hedn"},"type":"","url":"https://hackage.haskell.org/package/hedn/docs/Data-EDN.html#v:Map"},{"docs":"<pre>\n{:a map}\n</pre>\n","item":"<span class=name><s0>Map</s0></span> :: EDNMap -&gt; Value","module":{"name":"Data.EDN.AST.Types.Value","url":"https://hackage.haskell.org/package/hedn/docs/Data-EDN-AST-Types-Value.html"},"package":{"name":"hedn","url":"https://hackage.haskell.org/package/hedn"},"type":"","url":"https://hackage.haskell.org/package/hedn/docs/Data-EDN-AST-Types-Value.html#v:Map"},{"docs":"","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"Data.Map.Strict.Decaying","url":"https://hackage.haskell.org/package/net-mqtt/docs/Data-Map-Strict-Decaying.html"},"package":{"name":"net-mqtt","url":"https://hackage.haskell.org/package/net-mqtt"},"type":"","url":"https://hackage.haskell.org/package/net-mqtt/docs/Data-Map-Strict-Decaying.html#t:Map"},{"docs":"A map of values that expire after a given generation.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> g k a","module":{"name":"Data.Map.Strict.Expiring","url":"https://hackage.haskell.org/package/net-mqtt/docs/Data-Map-Strict-Expiring.html"},"package":{"name":"net-mqtt","url":"https://hackage.haskell.org/package/net-mqtt"},"type":"","url":"https://hackage.haskell.org/package/net-mqtt/docs/Data-Map-Strict-Expiring.html#t:Map"},{"docs":"","item":"<b>module</b> TOML.Utils.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"toml-reader","url":"https://hackage.haskell.org/package/toml-reader"},"type":"module","url":"https://hackage.haskell.org/package/toml-reader/docs/TOML-Utils-Map.html"},{"docs":"Not on Stackage, so not searched.\nClass of key-value maps\n","item":"<b>package</b> <span class=name><s0>Map</s0></span>","module":{},"package":{},"type":"package","url":"https://hackage.haskell.org/package/Map"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> () =&gt; <span class=name><s0>Map</s0></span> k a","module":{"name":"Distribution.Solver.Compat.Prelude","url":"https://hackage.haskell.org/package/cabal-install-solver/docs/Distribution-Solver-Compat-Prelude.html"},"package":{"name":"cabal-install-solver","url":"https://hackage.haskell.org/package/cabal-install-solver"},"type":"","url":"https://hackage.haskell.org/package/cabal-install-solver/docs/Distribution-Solver-Compat-Prelude.html#t:Map"},{"docs":"A non-blocking concurrent map from hashable keys to values.\n\nThe implementation is based on <i>lock-free concurrent hash tries</i>\n(aka <i>Ctries</i>) as described by:\n\n<ul>\n<li>Aleksander Prokopec, Phil Bagwell, Martin Odersky, \"<i>Cache-Aware\nLock-Free Concurent Hash Tries</i>\"</li>\n<li>Aleksander Prokopec, Nathan G. Bronson, Phil Bagwell, Martin\nOdersky \"<i>Concurrent Tries with Efficient Non-Blocking\nSnapshots</i>\"</li>\n</ul>\n\nOperations have a worst-case complexity of <i>O(log n)</i>, with a\nbase equal to the size of the native <a>Word</a>.\n","item":"<b>module</b> Control.Concurrent.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"ctrie","url":"https://hackage.haskell.org/package/ctrie"},"type":"module","url":"https://hackage.haskell.org/package/ctrie/docs/Control-Concurrent-Map.html"},{"docs":"A map from keys <tt>k</tt> to values <tt>v</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k v","module":{"name":"Control.Concurrent.Map","url":"https://hackage.haskell.org/package/ctrie/docs/Control-Concurrent-Map.html"},"package":{"name":"ctrie","url":"https://hackage.haskell.org/package/ctrie"},"type":"","url":"https://hackage.haskell.org/package/ctrie/docs/Control-Concurrent-Map.html#t:Map"},{"docs":"","item":"<b>module</b> Cursor.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"cursor","url":"https://hackage.haskell.org/package/cursor"},"type":"module","url":"https://hackage.haskell.org/package/cursor/docs/Cursor-Map.html"},{"docs":"","item":"<b>module</b> Cursor.Simple.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"cursor","url":"https://hackage.haskell.org/package/cursor"},"type":"module","url":"https://hackage.haskell.org/package/cursor/docs/Cursor-Simple-Map.html"},{"docs":"A slightly less trivial implementation of range sets.\n\nThis is nearly identical to <a>Data.RangeSet.List</a> except for some\nimportant performance differences:\n\n<ul>\n<li>Most query functions in this module are <i>O(log n)</i> rather\nthan <i>O(n)</i>, so may be much faster.</li>\n<li>Most composition functions have the same time complexity but a\nhigher constant, so may be somewhat slower.</li>\n</ul>\n\nIf you're mainly calling <a>member</a>, you should consider using this\nmodule, but if you're calling <a>union</a>, <a>deleteRange</a>, and\nother range manipulation functions as often as querying, you might\nstick with the list implementation.\n\nThis module is intended to be imported qualified, to avoid name\nclashes with Prelude functions, e.g.\n\n<pre>\nimport Data.RangeSet.Map (RSet)\nimport qualified Data.RangeSet.Map as RSet\n</pre>\n\nThe implementation of <a>RSet</a> is based on <a>Data.Map.Strict</a>.\n","item":"<b>module</b> Data.RangeSet.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"range-set-list","url":"https://hackage.haskell.org/package/range-set-list"},"type":"module","url":"https://hackage.haskell.org/package/range-set-list/docs/Data-RangeSet-Map.html"},{"docs":"Maps that handle pairs of amplitudes and sampled values. They are a\nspecial form of arrows.\n","item":"<b>module</b> Synthesizer.Dimensional.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"synthesizer-dimensional","url":"https://hackage.haskell.org/package/synthesizer-dimensional"},"type":"module","url":"https://hackage.haskell.org/package/synthesizer-dimensional/docs/Synthesizer-Dimensional-Map.html"},{"docs":"4.8.13\n","item":"<span class=name><s0>Map</s0></span> :: Element &quot;map&quot; &#39;[Flow, Phrasing, Palpable] (Flow :|: (Phrasing :|: Palpable)) (NameA &amp; &#39;[])","module":{"name":"Html.Type","url":"https://hackage.haskell.org/package/type-of-html/docs/Html-Type.html"},"package":{"name":"type-of-html","url":"https://hackage.haskell.org/package/type-of-html"},"type":"","url":"https://hackage.haskell.org/package/type-of-html/docs/Html-Type.html#v:Map"},{"docs":"A static perfect hash table where the keys are byte arrays. This table\ncannot be updated after its creation, but all lookups have guaranteed\nO(1) worst-case cost. It consumes linear space. This is an excellent\ncandidate for use with compact regions.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> v","module":{"name":"Data.Bytes.HashMap","url":"https://hackage.haskell.org/package/bytehash/docs/Data-Bytes-HashMap.html"},"package":{"name":"bytehash","url":"https://hackage.haskell.org/package/bytehash"},"type":"","url":"https://hackage.haskell.org/package/bytehash/docs/Data-Bytes-HashMap.html#t:Map"},{"docs":"A static perfect hash table where the keys are byte arrays. This table\ncannot be updated after its creation, but all lookups have guaranteed\nO(1) worst-case cost. It consumes linear space. This is an excellent\ncandidate for use with compact regions.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span>","module":{"name":"Data.Bytes.HashMap.Word","url":"https://hackage.haskell.org/package/bytehash/docs/Data-Bytes-HashMap-Word.html"},"package":{"name":"bytehash","url":"https://hackage.haskell.org/package/bytehash"},"type":"","url":"https://hackage.haskell.org/package/bytehash/docs/Data-Bytes-HashMap-Word.html#t:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: [(Literal, Literal)] -&gt; Literal","module":{"name":"Codec.Beam","url":"https://hackage.haskell.org/package/codec-beam/docs/Codec-Beam.html"},"package":{"name":"codec-beam","url":"https://hackage.haskell.org/package/codec-beam"},"type":"","url":"https://hackage.haskell.org/package/codec-beam/docs/Codec-Beam.html#v:Map"},{"docs":"","item":"<b>newtype</b> <span class=name><s0>Map</s0></span> a b","module":{"name":"Database.CQL.Protocol","url":"https://hackage.haskell.org/package/cql/docs/Database-CQL-Protocol.html"},"package":{"name":"cql","url":"https://hackage.haskell.org/package/cql"},"type":"","url":"https://hackage.haskell.org/package/cql/docs/Database-CQL-Protocol.html#t:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: [(a, b)] -&gt; Map a b","module":{"name":"Database.CQL.Protocol","url":"https://hackage.haskell.org/package/cql/docs/Database-CQL-Protocol.html"},"package":{"name":"cql","url":"https://hackage.haskell.org/package/cql"},"type":"","url":"https://hackage.haskell.org/package/cql/docs/Database-CQL-Protocol.html#v:Map"},{"docs":"","item":"<b>newtype</b> <span class=name><s0>Map</s0></span> a b","module":{"name":"Database.CQL.Protocol.Internal","url":"https://hackage.haskell.org/package/cql/docs/Database-CQL-Protocol-Internal.html"},"package":{"name":"cql","url":"https://hackage.haskell.org/package/cql"},"type":"","url":"https://hackage.haskell.org/package/cql/docs/Database-CQL-Protocol-Internal.html#t:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: [(a, b)] -&gt; Map a b","module":{"name":"Database.CQL.Protocol.Internal","url":"https://hackage.haskell.org/package/cql/docs/Database-CQL-Protocol-Internal.html"},"package":{"name":"cql","url":"https://hackage.haskell.org/package/cql"},"type":"","url":"https://hackage.haskell.org/package/cql/docs/Database-CQL-Protocol-Internal.html#v:Map"},{"docs":"A <a>Data.Map</a> <tt><a>Map</a></tt> wrapper that allows direct\nlookup of keys that are known to exist in the map.\n\nHere, \"direct lookup\" means that once a key has been proven to exist\nin the map, it can be used to extract a value directly from the map,\nrather than requiring a <tt><a>Maybe</a></tt> layer.\n\n<tt><a>Map</a></tt> allows you to shift the burden of proof that a key\nexists in a map from \"prove at every lookup\" to \"prove once per key\".\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> ph k v","module":{"name":"Data.Map.Justified","url":"https://hackage.haskell.org/package/justified-containers/docs/Data-Map-Justified.html"},"package":{"name":"justified-containers","url":"https://hackage.haskell.org/package/justified-containers"},"type":"","url":"https://hackage.haskell.org/package/justified-containers/docs/Data-Map-Justified.html#t:Map"},{"docs":"","item":"<span class=name><s0>Map</s0></span> :: Schema -&gt; Schema","module":{"name":"Language.Avro.Types","url":"https://hackage.haskell.org/package/language-avro/docs/Language-Avro-Types.html"},"package":{"name":"language-avro","url":"https://hackage.haskell.org/package/language-avro"},"type":"","url":"https://hackage.haskell.org/package/language-avro/docs/Language-Avro-Types.html#v:Map"},{"docs":"","item":"<b>module</b> Data.Loc.Internal.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"loc","url":"https://hackage.haskell.org/package/loc"},"type":"module","url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Map.html"},{"docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","module":{"name":"Data.Loc.Internal.Prelude","url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Prelude.html"},"package":{"name":"loc","url":"https://hackage.haskell.org/package/loc"},"type":"","url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Prelude.html#t:Map"},{"docs":"Specialization of <a>MemoStateT</a> with <a>Map</a> as a container\n","item":"<b>module</b> Control.Monad.Trans.Memo.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"monad-memo","url":"https://hackage.haskell.org/package/monad-memo"},"type":"module","url":"https://hackage.haskell.org/package/monad-memo/docs/Control-Monad-Trans-Memo-Map.html"},{"docs":"","item":"<b>class</b> <span class=name><s0>Map</s0></span> set","module":{"name":"Reactive.Banana.MIDI.KeySet","url":"https://hackage.haskell.org/package/reactive-midyim/docs/Reactive-Banana-MIDI-KeySet.html"},"package":{"name":"reactive-midyim","url":"https://hackage.haskell.org/package/reactive-midyim"},"type":"","url":"https://hackage.haskell.org/package/reactive-midyim/docs/Reactive-Banana-MIDI-KeySet.html#t:Map"},{"docs":"","item":"<b>module</b> Data.Trie.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"trie-simple","url":"https://hackage.haskell.org/package/trie-simple"},"type":"module","url":"https://hackage.haskell.org/package/trie-simple/docs/Data-Trie-Map.html"},{"docs":"A contention-free STM hash map. \"Contention-free\" means that the map\nwill never cause spurious conflicts. A transaction operating on the\nmap will only ever have to retry if another transaction is operating\non the same key at the same time.\n","item":"<b>module</b> Control.Concurrent.STM.<span class=name><s0>Map</s0></span>","module":{},"package":{"name":"ttrie","url":"https://hackage.haskell.org/package/ttrie"},"type":"module","url":"https://hackage.haskell.org/package/ttrie/docs/Control-Concurrent-STM-Map.html"}]