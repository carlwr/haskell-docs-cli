[{"docs":"","item":"<b>module</b> Data.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"base","url":"https://hackage.haskell.org/package/base"},"type":"module","url":"https://hackage.haskell.org/package/base/docs/Data-Bifunctor.html"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> p","module":{"name":"Data.Bifunctor","url":"https://hackage.haskell.org/package/base/docs/Data-Bifunctor.html"},"package":{"name":"base","url":"https://hackage.haskell.org/package/base"},"type":"","url":"https://hackage.haskell.org/package/base/docs/Data-Bifunctor.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Control.Lens.Combinators","url":"https://hackage.haskell.org/package/lens/docs/Control-Lens-Combinators.html"},"package":{"name":"lens","url":"https://hackage.haskell.org/package/lens"},"type":"","url":"https://hackage.haskell.org/package/lens/docs/Control-Lens-Combinators.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Control.Lens.Review","url":"https://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html"},"package":{"name":"lens","url":"https://hackage.haskell.org/package/lens"},"type":"","url":"https://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Data.Bifunctor.Apply","url":"https://hackage.haskell.org/package/semigroupoids/docs/Data-Bifunctor-Apply.html"},"package":{"name":"semigroupoids","url":"https://hackage.haskell.org/package/semigroupoids"},"type":"","url":"https://hackage.haskell.org/package/semigroupoids/docs/Data-Bifunctor-Apply.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Protolude","url":"https://hackage.haskell.org/package/protolude/docs/Protolude.html"},"package":{"name":"protolude","url":"https://hackage.haskell.org/package/protolude"},"type":"","url":"https://hackage.haskell.org/package/protolude/docs/Protolude.html#t:Bifunctor"},{"docs":"","item":"<b>module</b> Protolude.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"protolude","url":"https://hackage.haskell.org/package/protolude"},"type":"module","url":"https://hackage.haskell.org/package/protolude/docs/Protolude-Bifunctor.html"},{"docs":"","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> p","module":{"name":"Protolude.Bifunctor","url":"https://hackage.haskell.org/package/protolude/docs/Protolude-Bifunctor.html"},"package":{"name":"protolude","url":"https://hackage.haskell.org/package/protolude"},"type":"","url":"https://hackage.haskell.org/package/protolude/docs/Protolude-Bifunctor.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Diagrams.Prelude","url":"https://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html"},"package":{"name":"diagrams-lib","url":"https://hackage.haskell.org/package/diagrams-lib"},"type":"","url":"https://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Streaming","url":"https://hackage.haskell.org/package/streaming/docs/Streaming.html"},"package":{"name":"streaming","url":"https://hackage.haskell.org/package/streaming"},"type":"","url":"https://hackage.haskell.org/package/streaming/docs/Streaming.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"BasePrelude","url":"https://hackage.haskell.org/package/base-prelude/docs/BasePrelude.html"},"package":{"name":"base-prelude","url":"https://hackage.haskell.org/package/base-prelude"},"type":"","url":"https://hackage.haskell.org/package/base-prelude/docs/BasePrelude.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"RIO.Prelude.Types","url":"https://hackage.haskell.org/package/rio/docs/RIO-Prelude-Types.html"},"package":{"name":"rio","url":"https://hackage.haskell.org/package/rio"},"type":"","url":"https://hackage.haskell.org/package/rio/docs/RIO-Prelude-Types.html#t:Bifunctor"},{"docs":"","item":"<b>module</b> Data.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"rerebase","url":"https://hackage.haskell.org/package/rerebase"},"type":"module","url":"https://hackage.haskell.org/package/rerebase/docs/Data-Bifunctor.html"},{"docs":"Useful combinators for bifunctors inside functors. This set of\nfunctions is useful when you want to work with types like these ones:\n\n<pre>\nfoo :: IO (Either a b)\nbar :: IO (a, b)\n\nbaz :: Maybe (Either a b)\nqux :: Maybe (a, b)\n\ndoo :: (a, a)\ndee :: Either a a\n</pre>\n","item":"<b>module</b> Relude.Extra.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"relude","url":"https://hackage.haskell.org/package/relude"},"type":"module","url":"https://hackage.haskell.org/package/relude/docs/Relude-Extra-Bifunctor.html"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Relude.Functor.Reexport","url":"https://hackage.haskell.org/package/relude/docs/Relude-Functor-Reexport.html"},"package":{"name":"relude","url":"https://hackage.haskell.org/package/relude"},"type":"","url":"https://hackage.haskell.org/package/relude/docs/Relude-Functor-Reexport.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Universum.Functor.Reexport","url":"https://hackage.haskell.org/package/universum/docs/Universum-Functor-Reexport.html"},"package":{"name":"universum","url":"https://hackage.haskell.org/package/universum"},"type":"","url":"https://hackage.haskell.org/package/universum/docs/Universum-Functor-Reexport.html#t:Bifunctor"},{"docs":"Class for (covariant) bifunctors.\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> p","module":{"name":"Optics.Internal.Bi","url":"https://hackage.haskell.org/package/optics-core/docs/Optics-Internal-Bi.html"},"package":{"name":"optics-core","url":"https://hackage.haskell.org/package/optics-core"},"type":"","url":"https://hackage.haskell.org/package/optics-core/docs/Optics-Internal-Bi.html#t:Bifunctor"},{"docs":"Bifunctors.\n\nBifunctors are \"two-argument functors\".\n\nThis module is the type-level equivalent of <a>Data.Bifunctor</a>.\n","item":"<b>module</b> Fcf.Class.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"first-class-families","url":"https://hackage.haskell.org/package/first-class-families"},"type":"module","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Class-Bifunctor.html"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Foundation","url":"https://hackage.haskell.org/package/foundation/docs/Foundation.html"},"package":{"name":"foundation","url":"https://hackage.haskell.org/package/foundation"},"type":"","url":"https://hackage.haskell.org/package/foundation/docs/Foundation.html#t:Bifunctor"},{"docs":"Formally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n","item":"<b>module</b> Foundation.Class.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"foundation","url":"https://hackage.haskell.org/package/foundation"},"type":"module","url":"https://hackage.haskell.org/package/foundation/docs/Foundation-Class-Bifunctor.html"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<tt>Functor</tt>, a type constructor such as <tt>Either</tt> does not\nneed to be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <tt>Left</tt>\nvalue or the <tt>Right</tt> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n","item":"<b>module</b> Basement.Compat.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"basement","url":"https://hackage.haskell.org/package/basement"},"type":"module","url":"https://hackage.haskell.org/package/basement/docs/Basement-Compat-Bifunctor.html"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Basement.Compat.Bifunctor","url":"https://hackage.haskell.org/package/basement/docs/Basement-Compat-Bifunctor.html"},"package":{"name":"basement","url":"https://hackage.haskell.org/package/basement"},"type":"","url":"https://hackage.haskell.org/package/basement/docs/Basement-Compat-Bifunctor.html#t:Bifunctor"},{"docs":"","item":"<b>module</b> Rebase.Data.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"type":"module","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Data-Bifunctor.html"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Rebase.Prelude","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html"},"package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"type":"","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Stack.Prelude","url":"https://hackage.haskell.org/package/stack/docs/Stack-Prelude.html"},"package":{"name":"stack","url":"https://hackage.haskell.org/package/stack"},"type":"","url":"https://hackage.haskell.org/package/stack/docs/Stack-Prelude.html#t:Bifunctor"},{"docs":"The Bifunctor class\n\n<h2>Laws</h2>\n\nIf <a>bimap</a> is supplied, then <tt><a>bimap</a> <a>id</a> <a>id</a>\n= <a>id</a></tt>\n\n<ul>\n<li>If <a>first</a> and <a>second</a> are supplied, then <tt>\n<a>first</a> <a>id</a> ≡ <a>id</a> <a>second</a> <a>id</a> ≡ <a>id</a>\n</tt></li>\n<li>If all are supplied, then @<a>bimap</a> f g = <a>first</a> f\n<a>.</a> <a>second</a> g</li>\n</ul>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> p","module":{"name":"Data.Bifunctor.Linear","url":"https://hackage.haskell.org/package/linear-base/docs/Data-Bifunctor-Linear.html"},"package":{"name":"linear-base","url":"https://hackage.haskell.org/package/linear-base"},"type":"","url":"https://hackage.haskell.org/package/linear-base/docs/Data-Bifunctor-Linear.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Data.Loc.Internal.Prelude","url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Prelude.html"},"package":{"name":"loc","url":"https://hackage.haskell.org/package/loc"},"type":"","url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Prelude.html#t:Bifunctor"},{"docs":"<a>TextShow</a> instances for data types in the <tt>bifunctors</tt>\nlibrary.\n\n<i>Since: 2</i>\n","item":"<b>module</b> TextShow.Data.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"text-show-instances","url":"https://hackage.haskell.org/package/text-show-instances"},"type":"module","url":"https://hackage.haskell.org/package/text-show-instances/docs/TextShow-Data-Bifunctor.html"},{"docs":"The category of quivers forms a closed monoidal category in two ways,\nunder <a>ProductQ</a> or <a>ComposeQ</a>. The relations between these\nand their adjoints can be characterized by typeclasses below.\n","item":"<b>module</b> Data.Quiver.<span class=name><s0>Bifunctor</s0></span>","module":{},"package":{"name":"free-categories","url":"https://hackage.haskell.org/package/free-categories"},"type":"module","url":"https://hackage.haskell.org/package/free-categories/docs/Data-Quiver-Bifunctor.html"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Hledger.Web.Import","url":"https://hackage.haskell.org/package/hledger-web/docs/Hledger-Web-Import.html"},"package":{"name":"hledger-web","url":"https://hackage.haskell.org/package/hledger-web"},"type":"","url":"https://hackage.haskell.org/package/hledger-web/docs/Hledger-Web-Import.html#t:Bifunctor"},{"docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","module":{"name":"Termonad.Prelude","url":"https://hackage.haskell.org/package/termonad/docs/Termonad-Prelude.html"},"package":{"name":"termonad","url":"https://hackage.haskell.org/package/termonad"},"type":"","url":"https://hackage.haskell.org/package/termonad/docs/Termonad-Prelude.html#t:Bifunctor"},{"docs":"Not on Stackage, so not searched.\nBifunctors\n","item":"<b>package</b> <span class=name><s0>bifunctor</s0></span>","module":{},"package":{},"type":"package","url":"https://hackage.haskell.org/package/bifunctor"},{"docs":"","item":"<b>class</b> BifunctorFunctor t =&gt; <span class=name><s0>BifunctorComonad</s0></span> t","module":{"name":"Data.Bifunctor.Functor","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html"},"package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"type":"","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html#t:BifunctorComonad"},{"docs":"","item":"<b>class</b> <span class=name><s0>BifunctorFunctor</s0></span> t","module":{"name":"Data.Bifunctor.Functor","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html"},"package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"type":"","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html#t:BifunctorFunctor"},{"docs":"","item":"<b>class</b> BifunctorFunctor t =&gt; <span class=name><s0>BifunctorMonad</s0></span> t","module":{"name":"Data.Bifunctor.Functor","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html"},"package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"type":"","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html#t:BifunctorMonad"},{"docs":"","item":"<b>class</b> <span class=name><s0>BifunctorOf</s0></span> cat t","module":{"name":"Generic.Functor.Internal.Implicit","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html"},"package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"type":"","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html#t:BifunctorOf"},{"docs":"Bifunctors\n\nBifunctors.\n","item":"<b>package</b> <span class=name><s0>bifunctors</s0></span>","module":{},"package":{},"type":"package","url":"https://hackage.haskell.org/package/bifunctors"},{"docs":"Generates a <a>Bifunctor</a> instance declaration for the given data\ntype or data family instance.\n","item":"<span class=name><s0>deriveBifunctor</s0></span> :: Name -&gt; Q [Dec]","module":{"name":"Data.Bifunctor.TH","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-TH.html"},"package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"type":"","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-TH.html#v:deriveBifunctor"},{"docs":"Like <a>deriveBifunctor</a>, but takes an <a>Options</a> argument.\n","item":"<span class=name><s0>deriveBifunctorOptions</s0></span> :: Options -&gt; Name -&gt; Q [Dec]","module":{"name":"Data.Bifunctor.TH","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-TH.html"},"package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"type":"","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-TH.html#v:deriveBifunctorOptions"},{"docs":"","item":"<span class=name><s0>WrapBifunctor</s0></span> :: p a b -&gt; WrappedBifunctor p a b","module":{"name":"Data.Bifunctor.Wrapped","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html"},"package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"type":"","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html#v:WrapBifunctor"},{"docs":"Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.\n","item":"<b>newtype</b> <span class=name><s0>WrappedBifunctor</s0></span> p a b","module":{"name":"Data.Bifunctor.Wrapped","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html"},"package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"type":"","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html#t:WrappedBifunctor"},{"docs":"","item":"<span class=name><s0>unwrapBifunctor</s0></span> :: WrappedBifunctor p a b -&gt; p a b","module":{"name":"Data.Bifunctor.Wrapped","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html"},"package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"type":"","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html#v:unwrapBifunctor"},{"docs":"","item":"<span class=name><s0>bifoldableBifunctor</s0></span> :: forall p a b m . (Bifoldable p, Bifunctor p, Monoid m, Show (p a b), Arbitrary (p a b), Arbitrary m, CoArbitrary a, CoArbitrary b, EqProp m) =&gt; p a (b, m) -&gt; TestBatch","module":{"name":"Test.QuickCheck.Classes","url":"https://hackage.haskell.org/package/checkers/docs/Test-QuickCheck-Classes.html"},"package":{"name":"checkers","url":"https://hackage.haskell.org/package/checkers"},"type":"","url":"https://hackage.haskell.org/package/checkers/docs/Test-QuickCheck-Classes.html#v:bifoldableBifunctor"},{"docs":"","item":"<span class=name><s0>WrapBifunctor</s0></span> :: p a b -&gt; WrappedBifunctor (p :: k -&gt; k1 -&gt; Type) (a :: k) (b :: k1)","module":{"name":"Data.Functor.Invariant","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html"},"package":{"name":"invariant","url":"https://hackage.haskell.org/package/invariant"},"type":"","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html#v:WrapBifunctor"},{"docs":"Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.\n","item":"<b>newtype</b> <span class=name><s0>WrappedBifunctor</s0></span> (p :: k -&gt; k1 -&gt; Type) (a :: k) (b :: k1)","module":{"name":"Data.Functor.Invariant","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html"},"package":{"name":"invariant","url":"https://hackage.haskell.org/package/invariant"},"type":"","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html#t:WrappedBifunctor"},{"docs":"Every <a>Bifunctor</a> is also an <a>Invariant2</a> functor.\n","item":"<span class=name><s0>invmap2Bifunctor</s0></span> :: Bifunctor f =&gt; (a -&gt; c) -&gt; (c -&gt; a) -&gt; (b -&gt; d) -&gt; (d -&gt; b) -&gt; f a b -&gt; f c d","module":{"name":"Data.Functor.Invariant","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html"},"package":{"name":"invariant","url":"https://hackage.haskell.org/package/invariant"},"type":"","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html#v:invmap2Bifunctor"},{"docs":"","item":"<span class=name><s0>unwrapBifunctor</s0></span> :: WrappedBifunctor (p :: k -&gt; k1 -&gt; Type) (a :: k) (b :: k1) -&gt; p a b","module":{"name":"Data.Functor.Invariant","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html"},"package":{"name":"invariant","url":"https://hackage.haskell.org/package/invariant"},"type":"","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html#v:unwrapBifunctor"},{"docs":"","item":"<span class=name><s0>WrapBifunctor</s0></span> :: p a b -&gt; WrappedBifunctor (p :: k -&gt; k1 -&gt; Type) (a :: k) (b :: k1)","module":{"name":"Rebase.Prelude","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html"},"package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"type":"","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html#v:WrapBifunctor"},{"docs":"Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.\n","item":"<b>newtype</b> <span class=name><s0>WrappedBifunctor</s0></span> (p :: k -&gt; k1 -&gt; Type) (a :: k) (b :: k1)","module":{"name":"Rebase.Prelude","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html"},"package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"type":"","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html#t:WrappedBifunctor"},{"docs":"Every <a>Bifunctor</a> is also an <a>Invariant2</a> functor.\n","item":"<span class=name><s0>invmap2Bifunctor</s0></span> :: Bifunctor f =&gt; (a -&gt; c) -&gt; (c -&gt; a) -&gt; (b -&gt; d) -&gt; (d -&gt; b) -&gt; f a b -&gt; f c d","module":{"name":"Rebase.Prelude","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html"},"package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"type":"","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html#v:invmap2Bifunctor"},{"docs":"","item":"<span class=name><s0>unwrapBifunctor</s0></span> :: WrappedBifunctor (p :: k -&gt; k1 -&gt; Type) (a :: k) (b :: k1) -&gt; p a b","module":{"name":"Rebase.Prelude","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html"},"package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"type":"","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html#v:unwrapBifunctor"},{"docs":"Not on Stackage, so not searched.\nBifunctors over monad transformers.\n","item":"<b>package</b> <span class=name><s0>transformers-bifunctors</s0></span>","module":{},"package":{},"type":"package","url":"https://hackage.haskell.org/package/transformers-bifunctors"},{"docs":"Not on Stackage, so not searched.\nexport useful functions from `bifunctors`.\n","item":"<b>package</b> <span class=name><s0>papa-bifunctors-export</s0></span>","module":{},"package":{},"type":"package","url":"https://hackage.haskell.org/package/papa-bifunctors-export"},{"docs":"Not on Stackage, so not searched.\nuseful `bifunctors` functions reimplemented\n","item":"<b>package</b> <span class=name><s0>papa-bifunctors-implement</s0></span>","module":{},"package":{},"type":"package","url":"https://hackage.haskell.org/package/papa-bifunctors-implement"},{"docs":"Generic <a>Bifunctor</a>.\n","item":"<b>class</b> (GBimap f, GFirst f, GSecond f) =&gt; <span class=name><s0>GBifunctor</s0></span> f","module":{"name":"Generic.Functor","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html"},"package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"type":"","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html#t:GBifunctor"},{"docs":"<tt>newtype</tt> for <tt>DerivingVia</tt> of <a>Bifunctor</a> and\n<a>Bifoldable</a> instances.\n\nNote: although <a>GenericBifunctor</a> has <a>Functor</a> and\n<a>Foldable</a> instances, it is recommended to use\n<a>GenericFunctor</a> instead for those two classes. They have to use\na separate deriving clause from <a>Bifunctor</a> and <a>Bifoldable</a>\nanyway. Those instances exist because they are to become superclasses\nof <a>Bifunctor</a> and <a>Bifoldable</a>. The <a>Foldable</a>\ninstance of <a>GenericBifunctor</a> is also less efficient than\n<a>GenericFunctor</a> unless the extra <tt>const mempty</tt> gets\noptimized away.\n\n<h3>Example</h3>\n\n<pre>\n{-# LANGUAGE DeriveGeneric, DerivingVia #-}\n\nimport <a>Data.Bifoldable</a> (<a>Bifoldable</a>)\nimport <a>Data.Bifunctor</a> (<a>Bifunctor</a>)\nimport <a>GHC.Generics</a> (<a>Generic</a>)\nimport <a>Generic.Functor</a> (<a>GenericFunctor</a>(..), <a>GenericBifunctor</a>(..))\n\ndata Tree a b = Node a (Tree a b) (Tree a b) | Leaf b\nderiving <a>Generic</a>\nderiving (<a>Functor</a>, <a>Foldable</a>) via (<a>GenericFunctor</a> (Tree a))\nderiving (<a>Bifunctor</a>, <a>Bifoldable</a>) via (<a>GenericBifunctor</a> Tree)\n\ndata CofreeF f a b = a :&lt; f b\nderiving <a>Generic</a>\nderiving (<a>Bifunctor</a>, <a>Bifoldable</a>) via (<a>GenericBifunctor</a> (CofreeF f))\n</pre>\n","item":"<b>newtype</b> <span class=name><s0>GenericBifunctor</s0></span> f a b","module":{"name":"Generic.Functor","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html"},"package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"type":"","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html#t:GenericBifunctor"},{"docs":"","item":"<span class=name><s0>GenericBifunctor</s0></span> :: f a b -&gt; GenericBifunctor f a b","module":{"name":"Generic.Functor","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html"},"package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"type":"","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html#v:GenericBifunctor"},{"docs":"Generic <a>Bifunctor</a>.\n","item":"<b>class</b> (GBimap f, GFirst f, GSecond f) =&gt; <span class=name><s0>GBifunctor</s0></span> f","module":{"name":"Generic.Functor.Internal","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html"},"package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"type":"","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html#t:GBifunctor"},{"docs":"<tt>newtype</tt> for <tt>DerivingVia</tt> of <a>Bifunctor</a> and\n<a>Bifoldable</a> instances.\n\nNote: although <a>GenericBifunctor</a> has <a>Functor</a> and\n<a>Foldable</a> instances, it is recommended to use\n<a>GenericFunctor</a> instead for those two classes. They have to use\na separate deriving clause from <a>Bifunctor</a> and <a>Bifoldable</a>\nanyway. Those instances exist because they are to become superclasses\nof <a>Bifunctor</a> and <a>Bifoldable</a>. The <a>Foldable</a>\ninstance of <a>GenericBifunctor</a> is also less efficient than\n<a>GenericFunctor</a> unless the extra <tt>const mempty</tt> gets\noptimized away.\n\n<h3>Example</h3>\n\n<pre>\n{-# LANGUAGE DeriveGeneric, DerivingVia #-}\n\nimport <a>Data.Bifoldable</a> (<a>Bifoldable</a>)\nimport <a>Data.Bifunctor</a> (<a>Bifunctor</a>)\nimport <a>GHC.Generics</a> (<a>Generic</a>)\nimport <a>Generic.Functor</a> (<a>GenericFunctor</a>(..), <a>GenericBifunctor</a>(..))\n\ndata Tree a b = Node a (Tree a b) (Tree a b) | Leaf b\nderiving <a>Generic</a>\nderiving (<a>Functor</a>, <a>Foldable</a>) via (<a>GenericFunctor</a> (Tree a))\nderiving (<a>Bifunctor</a>, <a>Bifoldable</a>) via (<a>GenericBifunctor</a> Tree)\n\ndata CofreeF f a b = a :&lt; f b\nderiving <a>Generic</a>\nderiving (<a>Bifunctor</a>, <a>Bifoldable</a>) via (<a>GenericBifunctor</a> (CofreeF f))\n</pre>\n","item":"<b>newtype</b> <span class=name><s0>GenericBifunctor</s0></span> f a b","module":{"name":"Generic.Functor.Internal","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html"},"package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"type":"","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html#t:GenericBifunctor"},{"docs":"","item":"<span class=name><s0>GenericBifunctor</s0></span> :: f a b -&gt; GenericBifunctor f a b","module":{"name":"Generic.Functor.Internal","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html"},"package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"type":"","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html#v:GenericBifunctor"},{"docs":"","item":"<b>data</b> <span class=name><s0>AnyBifunctor</s0></span>","module":{"name":"Generic.Functor.Internal.Implicit","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html"},"package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"type":"","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html#t:AnyBifunctor"},{"docs":"","item":"<span class=name><s0>AnyBifunctor</s0></span> :: AnyBifunctor","module":{"name":"Generic.Functor.Internal.Implicit","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html"},"package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"type":"","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html#v:AnyBifunctor"},{"docs":"Not on Stackage, so not searched.\nPrelude with only useful functions\n","item":"<b>package</b> <span class=name><s0>papa-bifunctors</s0></span>","module":{},"package":{},"type":"package","url":"https://hackage.haskell.org/package/papa-bifunctors"}]